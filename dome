#!/usr/bin/env bash
set -euo pipefail

readonly VERSION="v1.0.0"
readonly DOME_CONFIG="${HOME}/.config/dome/config.yaml"

# Dependencies
readonly DEPS=(
  "yq"
  "rsync"
  "git"
)

# Print functions with colors and symbols for improved UX
declare -A COLORS=(
  [reset]="\033[0m"
  [bold]="\033[1m"
  [red]="\033[31m"
  [green]="\033[32m"
  [yellow]="\033[33m"
  [blue]="\033[34m"
  [magenta]="\033[35m"
)
declare -A SYMBOLS=(
  [check]="✓"
  [cross]="✗"
  [arrow]="➜"
  [info]="ℹ"
  [warn]="⚠"
)

# --- Helper Functions ---

# Expand tilde (~) to $HOME
resolve_path() {
  local path="$1"
  echo "${path/#\~/$HOME}"
}

# Read a value from the YAML config and trim any surrounding quotes/whitespace.
yaml_get() {
  local value
  value=$(yq "$1" "$2")
  echo "$value" | sed -e 's/^"\(.*\)"$/\1/' | xargs
}

# Retrieve the repository root from config and expand ~
get_repo_root() {
  local repo_path
  repo_path=$(yaml_get '.meta.local_path' "$DOME_CONFIG")
  resolve_path "$repo_path"
}

# Detect current distro (uses /etc/os-release if available)
detect_distro() {
  if [ -f /etc/os-release ]; then
    # Use env -u VERSION to avoid conflicts with our global VERSION
    local id id_like
    id=$(env -u VERSION HOME="$HOME" PATH="$PATH" bash -c '. /etc/os-release; echo "$ID"')
    id_like=$(env -u VERSION HOME="$HOME" PATH="$PATH" bash -c '. /etc/os-release; echo "$ID_LIKE"')
    # Normalize to lowercase.
    id=$(echo "$id" | tr '[:upper:]' '[:lower:]')
    id_like=$(echo "$id_like" | tr '[:upper:]' '[:lower:]')

    # Prioritize known base families
    if echo "$id_like" | grep -qi "debian"; then
      echo "debian"
      return
    fi

    if echo "$id" | grep -qiE "arch"; then
      echo "arch"
      return
    fi

    if echo "$id" | grep -qi "fedora" || echo "$id_like" | grep -qi "fedora"; then
      echo "fedora"
      return
    fi

    if echo "$id" | grep -qi "suse" || echo "$id_like" | grep -qi "suse"; then
      echo "suse"
      return
    fi

    # For Ubuntu, even though $ID is "ubuntu", we want to treat it as debian-based.
    if [ "$id" = "ubuntu" ]; then
      if echo "$id_like" | grep -qi "debian"; then
        echo "debian"
      else
        echo "ubuntu"
      fi
      return
    fi

    # Fallback: just return the normalized $ID.
    echo "$id"
  else
    echo ""
  fi
}

# Prepare the ignore file for rsync: remove blank lines and comments (#)
prepare_exclude_file() {
  local ignore_file="$1"
  local temp_file
  temp_file=$(mktemp)
  grep -vE '^\s*(#|$)' "$ignore_file" >"$temp_file"
  echo "$temp_file"
}

print_status() {
  local color="$1" symbol="$2" msg="$3"
  if [[ -t 1 ]]; then
    echo -e "${COLORS[bold]}${COLORS[$color]}${SYMBOLS[$symbol]} ${msg}${COLORS[reset]}"
  else
    echo "${SYMBOLS[$symbol]} ${msg}"
  fi
}

print_success() { print_status "green" "check" "$1"; }
print_error() { print_status "red" "cross" "$1"; }
print_info() { print_status "blue" "arrow" "$1"; }
print_warning() { print_status "yellow" "warn" "$1"; }
print_notice() { print_status "magenta" "info" "$1"; }

# Run hook commands defined in the YAML config (if any)
run_hook() {
  local hook_name="$1"
  local hook_cmd
  hook_cmd=$(yaml_get ".hooks.$hook_name" "$DOME_CONFIG")
  # If hook_cmd is empty or equals "null", do nothing.
  if [[ -z "$hook_cmd" || "$hook_cmd" == "null" ]]; then
    return 0
  fi
  print_info "Running $hook_name hook..."
  eval "$hook_cmd" || return 1
}

# --- Core Functions ---

initialize_dome() {
  print_info "Initializing dome..."

  mkdir -p "${HOME}/.config/dome"

  if [ ! -f "$DOME_CONFIG" ]; then
    cat >"$DOME_CONFIG" <<'EOF'
meta:
  repo: "https://github.com/yourusername/dotfiles.git"
  branch: "main"
  local_path: "~/.dotfiles"

hooks:
  pre_sync: "echo 'hello world'"
  post_sync: ""
  conflict_resolver: "meld"

distro_files:
  # Example mapping:
  # .bashrc:
  #   arch: ".bashrc.arch"
  #   debian: ".bashrc.debian"
EOF
  fi

  local repo_root
  repo_root=$(get_repo_root)

  if [ ! -d "$repo_root/.git" ]; then
    git clone $(yaml_get '.meta.repo' "$DOME_CONFIG") "$repo_root" || {
      print_error "Failed to clone repository"
      exit 1
    }
  fi

  # Create default ignore file if not present.
  [ -f "${repo_root}/.domeignore" ] || cat >"${repo_root}/.domeignore" <<'EOF'
# Ignore Git files and dome config
.git/
.domeignore
README.md
LICENSE
EOF

  print_success "Initialization complete!"
}

# perform_sync integrates distro-specific file mapping into the sync process.
perform_sync() {
  run_hook "pre_sync" || return 1

  print_info "Starting bidirectional sync..."

  local repo_root
  repo_root=$(get_repo_root)
  local dome_ignore="${repo_root}/.domeignore"
  local exclude_file
  exclude_file=$(prepare_exclude_file "$dome_ignore")

  # --- Repo → Home Sync with Integrated Distro Mapping ---
  # Create a temporary directory as a merged view of the repo.
  local tmp_repo
  tmp_repo=$(mktemp -d)
  # Copy the repo contents (excluding .git) into the temporary directory.
  rsync -a --exclude='.git' "${repo_root}/" "$tmp_repo/"

  # Apply distro mapping: for each mapping key, if a distro-specific file is defined,
  # copy that file into the fallback location in the temporary view.
  local distro
  distro=$(detect_distro)
  # Get keys from the distro_files mapping.
  mapfile -t mapping_keys < <(yaml_get '.distro_files | keys | .[]' "$DOME_CONFIG")
  for dest in "${mapping_keys[@]}"; do
    local mapped
    mapped=$(yaml_get ".distro_files[\"$dest\"].$distro" "$DOME_CONFIG")
    if [[ "$mapped" != "null" && -n "$mapped" ]]; then
      if [ -e "${repo_root}/$mapped" ]; then
        cp -a "${repo_root}/$mapped" "${tmp_repo}/$dest"
      fi
    fi
  done

  # Use the merged view to sync files from repo to home.
  if rsync -rtlD --checksum --exclude-from="$exclude_file" "$tmp_repo/" "${HOME}/"; then
    print_success "Repo → Home sync complete"
  else
    print_error "Repo → Home sync failed"
    rm -rf "$tmp_repo" "$exclude_file"
    return 1
  fi

  rm -rf "$tmp_repo"

  # --- Conflict Detection ---
  print_info "Checking for conflicts..."
  local conflict=0
  while IFS= read -r -d '' file; do
    local relative_file="${file#./}"
    if [ -e "${HOME}/${relative_file}" ]; then
      if ! diff -q "${HOME}/${relative_file}" "${repo_root}/${relative_file}" >/dev/null; then
        conflict=1
        print_warning "Conflict detected for file: ${relative_file}"
      fi
    fi
  done < <(cd "$repo_root" && find . -type f -print0)

  if ((conflict)); then
    print_warning "Conflicts detected! Resolve with:"
    echo -e "  ${COLORS[bold]}dome resolve${COLORS[reset]}"
    rm -f "$exclude_file"
    return 1
  fi

  # --- Home → Repo Sync with Integrated Distro Mapping ---
  # Instead of syncing the whole home directory, update only tracked files.
  while IFS= read -r -d '' file; do
    local relative_file="${file#./}"
    if [ -e "${HOME}/${relative_file}" ]; then
      local updated=false
      # If this file is in the distro mapping, update the distro-specific file.
      for dest in "${mapping_keys[@]}"; do
        if [ "$relative_file" == "$dest" ]; then
          local mapped
          mapped=$(yaml_get ".distro_files[\"$dest\"].$distro" "$DOME_CONFIG")
          if [[ "$mapped" != "null" && -n "$mapped" ]]; then
            rsync -a --checksum "${HOME}/${relative_file}" "${repo_root}/$mapped"
            updated=true
            break
          fi
        fi
      done
      # Otherwise, update the same file in the repo.
      if [ "$updated" = false ]; then
        rsync -a --checksum "${HOME}/${relative_file}" "${repo_root}/${relative_file}"
      fi
    fi
  done < <(cd "$repo_root" && find . -type f -print0)

  print_success "Home → Repo sync complete"
  rm -f "$exclude_file"

  run_hook "post_sync" || return 1
}

dome_pull() {
  run_hook "pre_pull" || return 1

  local repo_root
  repo_root=$(get_repo_root)
  print_info "Pulling latest changes..."
  git -C "$repo_root" pull origin "$(yaml_get '.meta.branch' "$DOME_CONFIG")" || {
    print_error "Pull failed"
    return 1
  }

  run_hook "post_pull" || return 1
}

dome_push() {
  run_hook "pre_push" || return 1

  local repo_root
  repo_root=$(get_repo_root)
  print_info "Pushing changes..."
  git -C "$repo_root" push origin "$(yaml_get '.meta.branch' "$DOME_CONFIG")" || {
    print_error "Push failed"
    return 1
  }

  run_hook "post_push" || return 1
}

resolve_conflicts() {
  local merge_tool
  merge_tool=$(yaml_get '.hooks.conflict_resolver' "$DOME_CONFIG")
  if ! command -v "$merge_tool" >/dev/null; then
    print_error "Merge tool not found: $merge_tool"
    return 1
  fi
  local repo_root
  repo_root=$(get_repo_root)
  print_info "Launching $merge_tool..."
  "$merge_tool" "$repo_root" "$HOME"
}

usage() {
  cat <<EOF
Usage: ${0##*/} [COMMAND]

A minimalist dotfiles manager with atomic sync capabilities

Commands:
  init            Initialize configuration
  sync            Sync dotfiles bidirectionally
  pull            Update from remote repository
  push            Publish changes to remote
  resolve         Launch merge tool for conflicts
  -h, --help      Show this help
  -v, --version   Show version

Documentation: https://github.com/vvhybe/dome
EOF
}

# Add dependencies here, or leave empty if none
list_deps() {
  if [[ ${#DEPS[@]} -eq 0 ]]; then
    print_notice "This script has no dependencies."
  fi

  for dep in "${DEPS[@]}"; do
    print_notice "$dep"
  done
  return 0
}

main() {
  if [ $# -eq 0 ]; then
    usage
    exit 1
  fi

  case "$1" in
  init) initialize_dome ;;
  sync) perform_sync ;;
  pull) dome_pull ;;
  push) dome_push ;;
  resolve) resolve_conflicts ;;
  -v | --version) echo "dome $VERSION" ;;
  --deps) list_deps ;;
  -h | --help) usage ;;
  *)
    usage
    exit 1
    ;;
  esac
}

main "$@"
