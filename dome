#!/usr/bin/env bash
set -euo pipefail

detect_distro() {
  grep -qEi "arch" /etc/os-release 2>/dev/null && echo "arch" && return
  grep -qEi "debian|ubuntu" /etc/os-release 2>/dev/null && echo "debian" && return
  grep -qEi "fedora" /etc/os-release 2>/dev/null && echo "fedora" && return
  echo "generic"
}

readonly DOME_VERSION="v2.1.1"
readonly DOME_CONFIG="${HOME}/.config/dome/config.yaml"
readonly BACKUP_DIR="${HOME}/.config/dome/bak_$(date +%s)_$(detect_distro)"

# Dependencies
readonly DEPS=("git" "yq")

# UI Components
declare -A COLORS=(
  [reset]="\033[0m" [bold]="\033[1m" [dim]="\033[2m"
  [red]="\033[31m" [green]="\033[32m" [yellow]="\033[33m"
  [blue]="\033[34m" [magenta]="\033[35m" [cyan]="\033[36m"
  [bg_blue]="\033[44m" [bg_green]="\033[42m" [bg_red]="\033[41m" [bg_yellow]="\033[43m"
)

declare -A SYMBOLS=(
  [check]="✓" [cross]="✗" [arrow]="➜" [info]=""
  [warn]="⚠" [link]="🔗" [repo]="📦" [home]="🏠" [copy]="📄"
)

# --- UI Helpers ---
print_status() {
  local color="$1" symbol="$2" msg="$3"
  [[ -t 1 ]] && echo -e "${COLORS[bold]}${COLORS[$color]}${SYMBOLS[$symbol]} ${msg}${COLORS[reset]}" || echo "${SYMBOLS[$symbol]} ${msg}"
}
print_success() { print_status "green" "check" "$1"; }
print_error() { print_status "red" "cross" "$1"; }
print_info() { print_status "blue" "arrow" "$1"; }
print_warning() { print_status "yellow" "warn" "$1"; }
print_notice() { print_status "magenta" "info" "$1"; }
print_link() { print_status "cyan" "link" "$1"; }
print_copy() { print_status "green" "copy" "$1"; }

# Function to truncate paths for display in the table
truncate_path() {
  local path="$1" max_length="$2"
  if [[ ${#path} -gt $max_length ]]; then
    local filename=$(basename "$path")
    local dir_max=$((max_length - ${#filename} - 4))
    [[ $dir_max -lt 3 ]] && echo "...${path: -max_length + 3}" || echo ".../${path: -dir_max}/$filename"
  else
    echo "$path"
  fi
}

spinner() {
  local pid=$1 msg=$2 delay=0.15 spinstr='|/-\'
  while kill -0 $pid 2>/dev/null; do
    printf " [%c] %s" "$spinstr" "$msg"
    spinstr=${spinstr#?}${spinstr%"${spinstr#?}"}
    sleep $delay
    printf "\r\033[K"
  done
}

# --- Core Functions ---
resolve_path() {
  [[ "$1" == /* ]] && echo "$1" || echo "$HOME/$1"
}

yaml_get() {
  yq e "$1" "$2"
}

yaml_set() {
  yq -i "$1" "$2"
}

get_repo_root() {
  resolve_path "$(yaml_get '.meta.local_path' "$DOME_CONFIG")"
}

run_hook() {
  local hook_name="$1"
  local hook_cmd=$(yaml_get ".hooks.$hook_name" "$DOME_CONFIG")
  [[ -n "$hook_cmd" && "$hook_cmd" != "null" ]] || return 0
  print_notice "Running $hook_name hook..."
  eval "$hook_cmd" || return 1
}

initialize_dome() {
  local custom_repo="" custom_path=""
  [[ $# -gt 0 && "$1" =~ ^(https?:\/\/|git@) ]] && custom_repo="$1" && shift
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      -p|--path) custom_path="$2"; shift 2 ;;
      *) shift ;;
    esac
  done

  local default_repo="https://github.com/<yourusername>/dotfiles"
  local default_local_path="${HOME}/.dotfiles"
  local repo="$(yaml_get '.meta.repo' "$DOME_CONFIG")"
  local final_path="$(yaml_get '.meta.local_path' "$DOME_CONFIG")"
  
  repo="${custom_repo:-${repo:-$default_repo}}"
  final_path="${custom_path:-${final_path:-$default_local_path}}"

  print_info "Initializing dotfile manager..."
  mkdir -p "${HOME}/.config/dome"

  if [[ -f "$DOME_CONFIG" ]]; then
    print_info "Config file already exists: $DOME_CONFIG"
    
    [[ -n "$custom_repo" ]] && yaml_set '.meta.repo = "'"$custom_repo"'"' "$DOME_CONFIG" && print_success "Updated repo URL in config file."
    [[ -n "$custom_path" ]] && yaml_set '.meta.local_path = "'"$custom_path"'"' "$DOME_CONFIG" && print_success "Updated local path in config file." && mkdir -p "$custom_path" && print_success "Created custom path: $custom_path"
  else 
    cat >"$DOME_CONFIG" <<EOF
meta:
  repo: "${custom_repo:-$default_repo}"
  branch: "main"
  local_path: "${custom_path:-$default_local_path}"
hooks:
  conflict_resolver: "meld"
  pre_sync: "echo 'hello world'"
  post_sync: "notify-send 'Dotfiles synced!'"
  pre_push: ""
  post_push: ""
  pre_pull: ""
  post_pull: ""
distro_files:
  .bash_aliases:
    arch: ".bash_aliases.arch"
    debian: ".bash_aliases.debian"
EOF
    print_success "Config file created: $DOME_CONFIG"
  fi

  if [[ "$repo" == "$default_repo" ]]; then
    print_error "The repository URL is set to the default/demo URL. Please update it in the config file: $DOME_CONFIG"
    return 1
  fi

  if [[ ! -d "$final_path/.git" ]]; then
    if [[ -n "$(ls -A "$final_path" 2>/dev/null)" ]]; then
      print_error "Directory $final_path already exists and is not empty."
      return 1
    fi
    print_info "Cloning repository from ${repo} into $final_path"
    git clone "${repo}" "$final_path" --branch "$(yaml_get '.meta.branch' "$DOME_CONFIG")" && print_success "Repository cloned successfully." || { print_error "Failed to clone repository from ${repo}"; return 1; }
  else
    print_info "Repository already exists at $final_path"
    local ignore_file="${final_path}/.domeignore"
    if [[ ! -f "$ignore_file" ]]; then
      mkdir -p "$(dirname "$ignore_file")"
      cat >"$ignore_file" <<EOF
# Default dome ignore patterns
.git/
.github/
.domeignore
README.md
LICENSE
EOF
      print_success "Created default .domeignore at: $ignore_file"
    fi
  fi

  print_success "Initialization complete!"
  print_notice "Next steps: Edit ${DOME_CONFIG} as needed and run 'dome sync'"
}

is_ignored() {
  local file="$1" repo_root="$2" ignore_file="${repo_root}/.domeignore"
  [[ -f "$ignore_file" ]] || return 1
  [[ "$file" == ".git" || "$file" == ".git/"* || "$file" == ".domeignore" ]] && return 0

  while IFS= read -r pattern; do
    [[ -z "$pattern" || "$pattern" == \#* ]] && continue

    # Handle negation patterns
    local negate=0
    if [[ "$pattern" == !* ]]; then
      negate=1
      pattern="${pattern:1}"
    fi

    # Remove trailing slash for directory patterns
    pattern="${pattern%/}"

    # Convert pattern to a regex
    pattern=$(echo "$pattern" | sed 's/[.[\*^$(){}?+|]/\\&/g; s/\*/.*/g; s/\?/./g; s/^/\\^/; s/$/\\$/')

    if [[ "$file" =~ $pattern ]]; then
      if [[ $negate -eq 1 ]]; then
        return 1
      else
        return 0
      fi
    fi
  done <"$ignore_file"
  return 1
}

print_table_row() {
  local file="$1" symlinked="$2" backuped="$3" header="${4:-false}"
  local file_color="reset" symlinked_color="reset" backuped_color="reset"
  local file_width=40 symlinked_width=10 backuped_width=20
  local file_margin=$((file_width + 1))

  if [[ "$header" == "true" ]]; then
    file_color="bg_blue" symlinked_color="bg_blue" backuped_color="bg_blue"
  else
    [[ "$symlinked" == "Yes" ]] && symlinked_color="green" || symlinked_color="blue"
    [[ "$backuped" == "--" ]] && backuped_color="dim" || backuped_color="yellow"
  fi

  local display_file
  [[ "$header" == "true" ]] && display_file="$file" || display_file=$(truncate_path "$file" $file_width)

  printf "${COLORS[$file_color]}%-${file_margin}s${COLORS[reset]} " "$display_file"
  printf "${COLORS[$symlinked_color]}%-${symlinked_width}s${COLORS[reset]} " "$symlinked"
  printf "${COLORS[$backuped_color]}%-${backuped_width}s${COLORS[reset]}\n" "$backuped"
}

link_or_copy_file() {
  local source="$1" target="$2" snapshot="$3" no_backup="$4" verbose="$5"
  local symlinked="No" backuped="--"
  mkdir -p "$(dirname "$target")"

  if [[ -e "$target" && "$target" != "$source" ]]; then
    if [[ -L "$target" ]]; then
      [[ "$(readlink "$target")" == "$source" && "$snapshot" != "true" ]] && symlinked="Yes" && [[ "$verbose" == "true" ]] && print_table_row "${target#$HOME/}" "$symlinked" "$backuped" && return 0
    fi
    if [[ "$no_backup" != "true" ]]; then
      local backup="${BACKUP_DIR}/${target#$HOME/}"
      mkdir -p "$(dirname "$backup")"
      [[ "$verbose" != "true" ]] && print_warning "Backing up existing file: ${target} → ${backup}"
      mv "$target" "$backup"
      backuped="$(basename "$backup")"
    else
      rm -f "$target"
    fi
  fi

  if [[ "$snapshot" == "true" ]]; then
    [[ "$verbose" != "true" ]] && print_copy "Copying file: ${source} → ${target}"
    cp -f "$source" "$target"
  else
    [[ "$verbose" != "true" ]] && print_link "Creating symlink: ${target} → ${source}"
    ln -sf "$source" "$target"
    symlinked="Yes"
  fi

  [[ "$verbose" == "true" ]] && print_table_row "${target#$HOME/}" "$symlinked" "$backuped"
}

sync_files() {
  local repo_root=$(get_repo_root) distro=$(detect_distro)
  local snapshot="${1:-false}" no_backup="${2:-false}" verbose="${3:-false}"
  declare -A distro_map used_sources=()

  [[ "$verbose" == "true" ]] && print_info "Syncing dotfiles (verbose mode)..." && echo && print_table_row "File" "Symlinked" "Backuped" "true" && printf "%-41s %-10s %-20s\n" "$(printf '%.0s-' {1..41})" "$(printf '%.0s-' {1..10})" "$(printf '%.0s-' {1..20})" || print_info "Detected distribution: ${distro}"

  while IFS= read -r key; do
    local src=$(yaml_get ".distro_files[\"$key\"].$distro" "$DOME_CONFIG")
    if [[ -n "$src" ]]; then
      distro_map["$key"]="$src"
      used_sources["$src"]=1
      [[ "$verbose" != "true" ]] && print_notice "Using distro variant: ${key} → ${src}"
    fi
  done < <(yaml_get '.distro_files | keys | .[]' "$DOME_CONFIG")

  for key in "${!distro_map[@]}"; do
    local src="${repo_root}/${distro_map[$key]}" target="${HOME}/${key}"
    [[ -f "$src" ]] && link_or_copy_file "$src" "$target" "$snapshot" "$no_backup" "$verbose"
  done

  [[ "$verbose" == "true" ]] && echo
}

perform_sync() {
  local snapshot="false" no_backup="false" verbose="false"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -s|--snapshot) snapshot="true"; shift ;;
      -n|--no-back) no_backup="true"; shift ;;
      -v|--verbose) verbose="true"; shift ;;
      *) shift ;;
    esac
  done

  run_hook "pre_sync"
  [[ "$snapshot" == "true" ]] && print_info "Starting sync in snapshot mode (copying files)..." || print_info "Starting sync in symlink mode..."
  [[ "$no_backup" == "true" ]] && print_notice "Backup creation is disabled"
  sync_files "$snapshot" "$no_backup" "$verbose"
  run_hook "post_sync"
  print_success "Sync completed successfully!"
}

revert_backup() {
  print_info "Reverting to backed up dotfiles..."
  local backup_dir="${1:-}"
  [[ -z "$backup_dir" ]] && print_error "No backup directory specified." && return 1

  if [[ ! -d "$backup_dir" ]]; then
    print_error "Backup directory does not exist: $backup_dir"
    return 1
  fi

  while IFS= read -r -d $'\0' backup_file; do
    local original_file="${HOME}/${backup_file#${backup_dir}/}"
    mv "$backup_file" "$original_file"
    print_success "Restored $original_file from $backup_file"
  done < <(find "$backup_dir" -type f -print0)

  print_success "Reversion to backups completed!"
}

dome_pull() {
  run_hook "pre_pull"
  print_info "Pulling updates..."
  git -C "$(get_repo_root)" pull origin "$(yaml_get '.meta.branch' "$DOME_CONFIG")"
  run_hook "post_pull"
  print_success "Repository updated successfully!"
}

dome_push() {
  run_hook "pre_push"
  print_info "Pushing changes..."
  git -C "$(get_repo_root)" push origin "$(yaml_get '.meta.branch' "$DOME_CONFIG")"
  run_hook "post_push"
  print_success "Changes pushed successfully!"
}

# --- Main ---
usage() {
  echo -e "${COLORS[bold]}dome ${DOME_VERSION}${COLORS[reset]}"
  cat <<EOF
Usage: dome [command] [options]
Commands:
  init [options]     Initialize configuration
  sync [options]     Sync dotfiles
  pull               Update from remote
  push               Publish changes
  revert [dir]       Revert to backed up dotfiles from specified directory
  -h                 Show help
  -v                 Show version
Init Options:
  -p, --path         Custom local path for dotfiles
Sync Options:
  -s, --snapshot     Copy files
  -n, --no-back      No backups
  -v, --verbose      Verbose output
EOF
}

main() {
  local cmd="${1:-}"
  shift 2>/dev/null || true
  case "$cmd" in
    init) initialize_dome "$@" ;;
    sync) perform_sync "$@" ;;
    pull) dome_pull ;;
    push) dome_push ;;
    revert) revert_backup "$@" ;;
    -v) echo -e "${COLORS[bold]}dome ${DOME_VERSION}${COLORS[reset]}" ;;
    -h|*) usage ;;
  esac
}

main "$@"