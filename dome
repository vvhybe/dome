#!/usr/bin/env bash
set -euo pipefail

readonly DOME_VERSION="v2.0.0"
readonly DOME_CONFIG="${HOME}/.config/dome/config.yaml"

# Dependencies
readonly DEPS=(
  "git"
  "yq"
)

# UI Components
declare -A COLORS=(
  [reset]="\033[0m"
  [bold]="\033[1m"
  [dim]="\033[2m"
  [red]="\033[31m"
  [green]="\033[32m"
  [yellow]="\033[33m"
  [blue]="\033[34m"
  [magenta]="\033[35m"
  [cyan]="\033[36m"
  [bg_blue]="\033[44m"
  [bg_green]="\033[42m"
  [bg_red]="\033[41m"
  [bg_yellow]="\033[43m"
)

declare -A SYMBOLS=(
  [check]="✓"
  [cross]="✗"
  [arrow]="➜"
  [info]=""
  [warn]="⚠"
  [link]="🔗"
  [repo]="📦"
  [home]="🏠"
  [copy]="📄"
)

# --- UI Helpers ---
print_status() {
  local color="$1" symbol="$2" msg="$3"
  [[ -t 1 ]] && echo -e "${COLORS[bold]}${COLORS[$color]}${SYMBOLS[$symbol]} ${msg}${COLORS[reset]}" || echo "${SYMBOLS[$symbol]} ${msg}"
}
print_success() { print_status "green" "check" "$1"; }
print_error() { print_status "red" "cross" "$1"; }
print_info() { print_status "blue" "arrow" "$1"; }
print_warning() { print_status "yellow" "warn" "$1"; }
print_notice() { print_status "magenta" "info" "$1"; }
print_link() { print_status "cyan" "link" "$1"; }
print_copy() { print_status "green" "copy" "$1"; }

# Function to truncate paths for display in the table
truncate_path() {
  local path="$1"
  local max_length="$2"

  if [[ ${#path} -gt $max_length ]]; then
    # Get the filename
    local filename=$(basename "$path")
    local filename_len=${#filename}

    # Calculate how much of the directory path we can keep
    local dir_max=$((max_length - filename_len - 4)) # 4 for ".../"

    if [[ $dir_max -lt 3 ]]; then
      # If we can't show much of the directory, just truncate the whole path
      echo "...${path:$((${#path} - max_length + 3))}"
    else
      # Show shortened directory + full filename
      local dir=$(dirname "$path")
      echo ".../${dir:$((${#dir} - dir_max))}/$filename"
    fi
  else
    echo "$path"
  fi
}

spinner() {
  local pid=$1 msg=$2
  local delay=0.15 spinstr='|/-\'
  while kill -0 $pid 2>/dev/null; do
    local temp=${spinstr#?}
    printf " [%c] %s" "$spinstr" "$msg"
    spinstr=$temp${spinstr%"$temp"}
    sleep $delay
    printf "\r\033[K"
  done
}

# --- Core Functions ---
resolve_path() { echo "${1/#\~/$HOME}"; }
yaml_get() {
  yq "$1" "$2" 2>/dev/null | sed -e 's/^"\(.*\)"$/\1/' -e 's/^'\''\(.*\)'\''$/\1/' | xargs
}
get_repo_root() { resolve_path "$(yaml_get '.meta.local_path' "$DOME_CONFIG")"; }
detect_distro() {
  grep -qEi "arch" /etc/os-release 2>/dev/null && echo "arch" && return
  grep -qEi "debian|ubuntu" /etc/os-release 2>/dev/null && echo "debian" && return
  grep -qEi "fedora" /etc/os-release 2>/dev/null && echo "fedora" && return
  echo "generic"
}

run_hook() {
  local hook_name="$1"
  local hook_cmd=$(yaml_get ".hooks.$hook_name" "$DOME_CONFIG")
  [[ -n "$hook_cmd" && "$hook_cmd" != "null" ]] || return 0

  print_notice "Running $hook_name hook..."
  eval "$hook_cmd" || return 1
}

initialize_dome() {
  local custom_repo="" custom_path=""

  # If the first argument looks like a URL, treat it as the custom repo.
  if [[ $# -gt 0 ]]; then
    if [[ "$1" =~ ^(https?:\/\/|git@) ]]; then
      custom_repo="$1"
      shift
    fi
  fi

  # Process optional -p/--path argument.
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
    -p | --path)
      custom_path="$2"
      shift 2
      ;;
    *)
      shift
      ;;
    esac
  done

  # Define default values.
  local default_repo="https://github.com/<yourusername>/dotfiles"
  local default_local_path
  default_local_path=$(resolve_path "~/.dotfiles")

  print_info "Initializing dotfile manager..."

  # Ensure the dome config directory exists.
  mkdir -p "${HOME}/.config/dome"

  # If config doesn't exist, create one with defaults (or override with provided values).
  if [[ ! -f "$DOME_CONFIG" ]]; then
    local repo_val="$default_repo"
    [[ -n "$custom_repo" ]] && repo_val="$custom_repo"

    local local_path_val="$default_local_path"
    [[ -n "$custom_path" ]] && local_path_val=$(resolve_path "$custom_path")

    cat >"$DOME_CONFIG" <<EOF
meta:
  repo: "$repo_val"
  branch: "main"
  local_path: "$local_path_val"
hooks:
  pre_sync: ""
  post_sync: ""
distro_files: {}
EOF
    print_success "Created default config file: $DOME_CONFIG"
  else
    print_info "Config file already exists at $DOME_CONFIG"
    # If a custom repo is provided and it differs from default, update the config.
    if [[ -n "$custom_repo" ]]; then
      local current_repo
      current_repo=$(yaml_get '.meta.repo' "$DOME_CONFIG")
      if [[ "$current_repo" != "$custom_repo" && "$custom_repo" != "$default_repo" ]]; then
        export NEW_REPO="$custom_repo"
        yq -i '.meta.repo = strenv(NEW_REPO)' "$DOME_CONFIG"
        print_success "Updated repo in config to $custom_repo"
      else
        print_info "Repo value unchanged (either default or already set)."
      fi
    fi
    # If a custom local path is provided and it differs, update the config.
    if [[ -n "$custom_path" ]]; then
      local current_local_path new_local_path
      current_local_path=$(resolve_path "$(yaml_get '.meta.local_path' "$DOME_CONFIG")")
      new_local_path=$(resolve_path "$custom_path")
      if [[ "$current_local_path" != "$new_local_path" ]]; then
        export NEW_LOCAL_PATH="$new_local_path"
        yq -i '.meta.local_path = strenv(NEW_LOCAL_PATH)' "$DOME_CONFIG"
        print_success "Updated local_path in config to $new_local_path"
      else
        print_info "Local path unchanged."
      fi
    fi
  fi

  # Determine repository directory from the config.
  local repo_dir
  repo_dir=$(resolve_path "$(yaml_get '.meta.local_path' "$DOME_CONFIG")")

  # Create the repository directory if it doesn't exist.
  if [[ ! -d "$repo_dir" ]]; then
    mkdir -p "$repo_dir"
    print_info "Created directory: $repo_dir"
  fi

  # Retrieve the repository URL from the config.
  local repo_url
  repo_url=$(yaml_get '.meta.repo' "$DOME_CONFIG")

  # If the repo URL is empty or equals the default repo, assume a demo mode.
  if [[ -z "$repo_url" || "$repo_url" == "$default_repo" ]]; then
    print_info "Using demo repository. Initializing local git repo at $repo_dir"
    if [[ ! -d "$repo_dir/.git" ]]; then
      (cd "$repo_dir" && git init)
      print_success "Local git repository initialized at $repo_dir"
    else
      print_info "Local git repository already exists at $repo_dir"
    fi
  else
    # Otherwise, clone the repository if it isn't already cloned.
    if [[ ! -d "$repo_dir/.git" ]]; then
      print_info "Cloning repository from $repo_url into $repo_dir"
      if git clone "$repo_url" "$repo_dir" --branch "$(yaml_get '.meta.branch' "$DOME_CONFIG")"; then
        print_success "Repository cloned successfully."
      else
        print_error "Failed to clone repository from $repo_url"
        return 1
      fi
    else
      print_info "Repository already exists at $repo_dir"
    fi
  fi

  # Create a default .domeignore file if it doesn't exist.
  local ignore_file="${repo_dir}/.domeignore"
  if [[ ! -f "$ignore_file" ]]; then
    cat >"$ignore_file" <<EOF
# Default dome ignore patterns
.git/
.github/
.domeignore
README.md
LICENSE
EOF
    print_success "Created default .domeignore at: $ignore_file"
  fi

  print_success "Initialization complete!"
  print_notice "Next steps: Edit ${DOME_CONFIG} as needed and run 'dome sync'"
}

# Check if a file should be ignored based on .domeignore
is_ignored() {
  local file="$1"
  local repo_root="$2"
  local ignore_file="${repo_root}/.domeignore"

  # If .domeignore doesn't exist, nothing is ignored
  [[ -f "$ignore_file" ]] || return 1

  # Basic patterns and common Git files that should always be ignored
  [[ "$file" == ".git" || "$file" == ".git/"* || "$file" == ".domeignore" ]] && return 0

  # Read patterns from .domeignore and check if file matches
  while IFS= read -r pattern; do
    # Skip comments and empty lines
    [[ -z "$pattern" || "$pattern" == \#* ]] && continue

    # Remove trailing slash for directory patterns
    pattern="${pattern%/}"

    # Check if file matches pattern
    if [[ "$file" == "$pattern" || "$file" == "$pattern"/* ]]; then
      return 0
    fi
  done <"$ignore_file"

  return 1
}

# Function to print a table row with colors
print_table_row() {
  local file="$1" symlinked="$2" backuped="$3" header="${4:-false}"
  local file_color="reset" symlinked_color="reset" backuped_color="reset"
  local file_width=40 symlinked_width=10 backuped_width=20
  local file_margin=$((file_width + 1))

  # Set colors based on values
  if [[ "$header" == "true" ]]; then
    file_color="bg_blue" symlinked_color="bg_blue" backuped_color="bg_blue"
  else
    # Symlink status colors
    if [[ "$symlinked" == "Yes" ]]; then
      symlinked_color="green"
    else
      symlinked_color="blue"
    fi

    # Backup status colors
    if [[ "$backuped" == "--" ]]; then
      backuped_color="dim"
    else
      backuped_color="yellow"
    fi
  fi

  # Truncate file path if needed
  local display_file
  if [[ "$header" == "true" ]]; then
    display_file="$file"
  else
    display_file=$(truncate_path "$file" $file_width)
  fi

  # Print the row with colors
  printf "${COLORS[$file_color]}%-${file_margin}s${COLORS[reset]} " "$display_file"
  printf "${COLORS[$symlinked_color]}%-${symlinked_width}s${COLORS[reset]} " "$symlinked"
  printf "${COLORS[$backuped_color]}%-${backuped_width}s${COLORS[reset]}\n" "$backuped"
}

# Function to create symlink or copy file based on snapshot mode
link_or_copy_file() {
  local source="$1" target="$2" snapshot="$3" no_backup="$4" verbose="$5"
  local symlinked="No" backuped="--"
  local action_type="symlink"

  # Create target directory if it doesn't exist
  mkdir -p "$(dirname "$target")"

  # Check if target exists and needs backup
  if [[ -e "$target" && "$target" != "$source" ]]; then
    if [[ -L "$target" ]]; then
      # If it's already a symlink to the right place, we're done
      if [[ "$(readlink "$target")" == "$source" && "$snapshot" != "true" ]]; then
        symlinked="Yes"
        [[ "$verbose" == "true" ]] && print_table_row "${target#$HOME/}" "$symlinked" "$backuped"
        return 0
      fi
    fi

    # Create backup if requested
    if [[ "$no_backup" != "true" ]]; then
      local backup="${target}.bak.$(date +%s)"
      if [[ "$verbose" != "true" ]]; then
        print_warning "Backing up existing file: ${target} → ${backup}"
      fi
      mv "$target" "$backup"
      backuped="$(basename "$backup")"
    else
      rm -f "$target"
    fi
  fi

  # Create symlink or copy file based on snapshot mode
  if [[ "$snapshot" == "true" ]]; then
    if [[ "$verbose" != "true" ]]; then
      print_copy "Copying file: ${source} → ${target}"
    fi
    cp -f "$source" "$target"
  else
    if [[ "$verbose" != "true" ]]; then
      print_link "Creating symlink: ${target} → ${source}"
    fi
    ln -sf "$source" "$target"
    symlinked="Yes"
  fi

  # Print verbose output if requested
  [[ "$verbose" == "true" ]] && print_table_row "${target#$HOME/}" "$symlinked" "$backuped"
}

sync_files() {
  local repo_root=$(get_repo_root) distro=$(detect_distro)
  local snapshot="${1:-false}" no_backup="${2:-false}" verbose="${3:-false}"
  declare -A distro_map used_sources=()

  # Print verbose header if requested
  if [[ "$verbose" == "true" ]]; then
    print_info "Syncing dotfiles (verbose mode)..."
    echo
    print_table_row "File" "Symlinked" "Backuped" "true"
    printf "%-41s %-10s %-20s\n" "$(printf '%.0s-' {1..41})" "$(printf '%.0s-' {1..10})" "$(printf '%.0s-' {1..20})"
  else
    print_info "Detected distribution: ${distro}"
  fi

  # Process distro-specific files mapping
  while IFS= read -r key; do
    local src=$(yaml_get ".distro_files[\"$key\"].$distro" "$DOME_CONFIG")
    [[ -z "$src" ]] && continue
    distro_map["$key"]="$src"
    used_sources["$src"]=1
    [[ "$verbose" != "true" ]] && print_notice "Using distro variant: ${key} → ${src}"
  done < <(yaml_get '.distro_files | keys | .[]' "$DOME_CONFIG")

  # Process distro-specific files
  for key in "${!distro_map[@]}"; do
    local src="${repo_root}/${distro_map[$key]}" target="${HOME}/${key}"
    [[ -f "$src" ]] && link_or_copy_file "$src" "$target" "$snapshot" "$no_backup" "$verbose"
  done

  # Process remaining files
  [[ "$verbose" != "true" ]] && print_info "Syncing common dotfiles..."
  while IFS= read -r -d $'\0' file; do
    local rel_file="${file#${repo_root}/}"
    # Skip if file is in used_sources or is ignored
    [[ "${used_sources[$rel_file]:-}" == "1" ]] && continue
    is_ignored "$rel_file" "$repo_root" && continue

    local target="${HOME}/${rel_file}"
    [[ -f "$file" ]] && link_or_copy_file "$file" "$target" "$snapshot" "$no_backup" "$verbose"
  done < <(find "$repo_root" -type f -print0)

  # Print end of table in verbose mode
  [[ "$verbose" == "true" ]] && echo
}

perform_sync() {
  local snapshot="false" no_backup="false" verbose="false"

  # Parse options
  while [[ $# -gt 0 ]]; do
    case "$1" in
    -s | --snapshot)
      snapshot="true"
      shift
      ;;
    -n | --no-back)
      no_backup="true"
      shift
      ;;
    -v | --verbose)
      verbose="true"
      shift
      ;;
    *) shift ;;
    esac
  done

  run_hook "pre_sync"

  # Show sync mode
  if [[ "$snapshot" == "true" ]]; then
    print_info "Starting sync in snapshot mode (copying files)..."
  else
    print_info "Starting sync in symlink mode..."
  fi

  # Show backup settings
  if [[ "$no_backup" == "true" ]]; then
    print_notice "Backup creation is disabled"
  fi

  sync_files "$snapshot" "$no_backup" "$verbose"

  run_hook "post_sync"
  print_success "Sync completed successfully!"
}

dome_pull() {
  run_hook "pre_pull"
  print_info "Pulling updates..."
  git -C "$(get_repo_root)" pull origin "$(yaml_get '.meta.branch' "$DOME_CONFIG")"
  run_hook "post_pull"
  print_success "Repository updated successfully!"
}

dome_push() {
  run_hook "pre_push"
  print_info "Pushing changes..."
  git -C "$(get_repo_root)" push origin "$(yaml_get '.meta.branch' "$DOME_CONFIG")"
  run_hook "post_push"
  print_success "Changes pushed successfully!"
}

# --- Main ---
usage() {
  echo -e "${COLORS[bold]}dome ${DOME_VERSION}${COLORS[reset]}"
  cat <<EOF
A lightweight dotfile manager with distribution-specific support
${COLORS[bold]}Usage:${COLORS[reset]}
  dome [command] [options]
${COLORS[bold]}Commands:${COLORS[reset]}
  init               Initialize configuration
  sync [options]     Sync dotfiles between repo and home
  pull               Update from remote repository
  push               Publish local changes
  -h                 Show help
  -v                 Show version
${COLORS[bold]}Sync Options:${COLORS[reset]}
  -s, --snapshot     Copy files instead of creating symlinks
  -n, --no-back      Disable backup file creation
  -v, --verbose      Show detailed sync information
${COLORS[dim]}See documentation for configuration options${COLORS[reset]}
EOF
}

main() {
  local cmd="${1:-}"
  shift 2>/dev/null || true

  case "$cmd" in
  init) initialize_dome ;;
  sync) perform_sync "$@" ;;
  pull) dome_pull ;;
  push) dome_push ;;
  -v) echo -e "${COLORS[bold]}dome ${DOME_VERSION}${COLORS[reset]}" ;;
  -h | *) usage ;;
  esac
}

main "$@"
